apply plugin: 'idea'
apply plugin: 'eclipse'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath group: 'com.layer', name: 'gradle-git-repo-plugin', version: '2.0.2'
    }
}

allprojects {

}

subprojects {

	def getVersionTag = { ->
    	def stdout = new ByteArrayOutputStream()
    		exec {
        		commandLine 'git', 'rev-list', 'HEAD', '--count'
        		standardOutput = stdout
    	}
    	return stdout.toString().trim()
	}

	apply plugin: 'java'
	apply plugin: 'maven-publish'
	apply plugin: 'git-repo'
	apply plugin: 'signing'

	repositories {
    	github("streamlio", "maven-repo", "master", "releases")
	}

	gitPublishConfig{
    	org = "streamlio"
    	repo = "maven-repo"
	}

	sourceCompatibility = 1.8
	targetCompatibility = 1.8

    group   = 'org.streamlio.connectors'
    version = '0.0.' + getVersionTag()

	repositories {
		jcenter()
	}

	test {
		useTestNG()
	}

	dependencies {
		compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.25'
		compile group: 'com.twitter.heron', name: 'heron-api', version: '0.15.2'
		compile group: 'com.google.guava', name: 'guava', version: '23.0'
		compile group: 'org.apache.logging.log4j', name: 'log4j-api', version: '2.9.0'
		compile group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.9.0'
		compile group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.9.0'
        compile group: 'com.typesafe', name: 'config', version: '1.3.1'
        compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.6'

		testCompile group: 'org.testng', name: 'testng', version: '6.11'
		testCompile group: 'org.mockito', name: 'mockito-all', version: '1.10.19'
	}

	// pom file name
	ext {
    	pomFilePath = "${project.projectDir}/build/pom.xml"
    	pomFile = file(pomFilePath)
	}

	task sourcesJar(type: Jar, dependsOn: classes) {
		classifier = 'sources'
		from sourceSets.main.allSource
	}

	task javadocJar(type: Jar, dependsOn: javadoc) {
		classifier = 'javadoc'
		from javadoc.destinationDir
	}

	// add configuration for pom signing
	configurations {
	    pom
	}

	// summarize artifacts
	artifacts {
	    archives jar
	    archives sourcesJar
	    archives javadocJar
	    if (pomFile.exists()) {
	        pom pomFile
	    }
	}

	// extract pom signature
	def getPomSignature = {
    	return project.tasks.signPom.signatureFiles.collect{it}[0]
	}

	// sign all artifacts
	task signJars (type : Sign, dependsOn: [jar, javadocJar, sourcesJar]) {
	    sign configurations.archives
	}

	// sign pom
	task signPom(type: Sign) {
    	sign configurations.pom
	}

	task preparePublication (dependsOn : signJars)

	artifacts {
		archives jar
		archives sourcesJar
		archives javadocJar
		if (pomFile.exists()) {
        	pom pomFile
    	}
	}

	task fatJar(type: Jar) {
		baseName = project.name + '-uber'
		from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
		with jar
	}

	publishing {
		publications {
			mavenJava(MavenPublication) {
				groupId project.group
				artifactId 'connector' + '-' + project.name
				version project.version

		  		from components.java

		  		artifact sourcesJar {
					classifier "sources"
		  		}

				artifact javadocJar {
					classifier "javadoc"
		  		}
			}
	 	}
	 	repositories {
        	maven {
            	url "file://${gitPublishConfig.home}/${gitPublishConfig.org}/${gitPublishConfig.repo}/releases"
       		}
    	}
	}

	task createPom {
		apply plugin: 'maven'
		description "Generates pom.xml"
		pom {
			project {
				groupId project.group
				artifactId 'connector' + '-' + project.name
				version project.version
				packaging 'jar'
			}
		}.withXml {
			def dependenciesNode = asNode().appendNode('dependencies')

			configurations.compile.allDependencies.each { dependency ->
				def dependencyNode = dependenciesNode.appendNode('dependency')
				dependencyNode.appendNode('groupId', dependency.group)
				dependencyNode.appendNode('artifactId', dependency.name)
				dependencyNode.appendNode('version', dependency.version)

				// for exclusions
				if (dependency.excludeRules.size() > 0) {
					def exclusions = dependencyNode.appendNode('exclusions')
					dependency.excludeRules.each { ExcludeRule ex ->
						def exclusion = exclusions.appendNode('exclusion')
						exclusion.appendNode('groupId', ex.group)
						exclusion.appendNode('artifactId', ex.module)
					}
				}
			}
		}.writeTo("$buildDir/pom.xml")
	}

	uploadArchives {
    	configuration = configurations.archives
    	repositories.mavenDeployer {
    	    pom.project {
    	        name name
    	        description description
    	        url "https://github.com/harningt/${project.name}"
    	        inceptionYear '2017'

    	        scm {
    	            connection 'scm:git:https://github.com/harningt/atomun-core.git'
    	            developerConnection 'scm:git:git@github.com:harningt/atomun-core.git'
    	            url 'https://github.com/harningt/atomun-core'
    	        }

    	        licenses {
    	            license {
    	                name 'Apache License, Version 2.0'
    	                url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
    	                distribution 'repo'
    	            }
    	        }
    	        developers {
    	            developer {
    	                id 'harningt'
    	                name 'Thomas Harning Jr'
    	                email 'harningt@gmail.com'
    	            }
    	        }
    	    }
    	    beforeDeployment { MavenDeployment deployment ->
    	        signing.signPom(deployment)
    	    }
    	}
	}

}

//Core
project(':core') {

}

//Pulsar
project(':pulsar') {
	dependencies {
		compile project(':core')
	}
}

//Kafka
project(':kafka') {
	dependencies {
		compile project(':core')
	}
}

//Examples
project(':examples') {
	dependencies {
		compile project(':core')
		compile project(':pulsar')
		compile project(':kafka')
	}
}
